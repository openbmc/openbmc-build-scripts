#!/usr/bin/env python3
###############################################################################
#
# This script is for starting QEMU against the input build and running the
# robot CI test suite against it.(ROBOT CI TEST CURRENTLY WIP)
#
###############################################################################
#
# Parameters used by the script:
#  UPSTREAM_WORKSPACE = The directory from which the QEMU components are being
#                       imported from. Generally, this is the build directory
#                       that is generated by the OpenBMC build-setup.sh script
#                       when run with "target=qemuarm".
#                       Example: /home/builder/workspace/openbmc-build/build.
#
# Optional Variables:
#
#  WORKSPACE          = Path of the workspace directory where some intermediate
#                       files will be saved to.
#  DOCKER_IMG_NAME    = Defaults to openbmc/ubuntu-robot-qemu, the name the
#                       Docker image will be tagged with when built.
#                       Added a "pull" semantic to actively pull the image.
#                       "pull container:latest"
#  OBMC_QEMU_BUILD_DIR     = Defaults to /tmp/openbmc/build, the path to the
#                       directory where the UPSTREAM_WORKSPACE build files will
#                       be mounted to. Since the build containers have been
#                       changed to use /tmp as the parent directory for their
#                       builds, move the mounting location to be the same to
#                       resolve issues with file links or referrals to exact
#                       paths in the original build directory. If the build
#                       directory was changed in the build-setup.sh run, this
#                       variable should also be changed. Otherwise, the default
#                       should be used.
#  LAUNCH             = Used to determine how to launch the qemu robot test
#                       containers. The options are "local", and "k8s". It will
#                       default to local which will launch a single container
#                       to do the runs. If specified k8s will launch a group of
#                       containers into a kubernetes cluster using the helper
#                       script.
#  QEMU_BIN           = Location of qemu-system-arm binary to use when starting
#                       QEMU relative to upstream workspace.  Default is
#                       ./tmp/sysroots/${QEMU_ARCH}/usr/bin/qemu-system-arm
#                       which is the default location when doing a bitbake
#                       of obmc-phosphor-image. If you don't find the sysroots
#                       folder, run `bitbake build-sysroots`.
#
#  MACHINE            = Machine to run test against. The options are "witherspoon",
#                       "palmetto", "romulus", or undefined (default).  Default
#                       will use the versatilepb model.
#
#  DEFAULT_IMAGE_LOC  = The image location of the target MACHINE. Default to
#                       "./tmp/deploy/images/"
#
#  OBMC_QEMU_DOCKER   = (testing) Use a persistent Docker container if runtime
#                       verified
#  KEEP_QEMU_PERSISTENT = (testing) if set, it will not attempt to stop the
#                       qemu container so that it is left persistent for
#                       testing.
#  INTERACT           = (testing) if set, it will allow for interactive
#                       session in the qemu container to bypass pexpect issues.
#  HOSTBIN            = (testing) use --network=host for Robot container and
#                       qmeu (container or process)
#  HOSTBINPERSIST     = (testing) if set then the qemu process manually run
#                       and is used without starting it within a container.
#
###############################################################################


import inspect
import json
import os
import subprocess
import sys
from datetime import datetime
import pexpect
import sh

def docker_inspect_check(container, exit_on_fail=False):
    """docker inspect and return JSON contents"""
    ret = subprocess.run(
        [DOCKER, "inspect", container], capture_output=True, check=False
    )
    if ret.returncode == 0:
        return ret.stdout.decode("utf-8").rstrip()
    else:
        if exit_on_fail:
            sys.exit(f"docker_inspect_check: failed {container}")
        return None

def get_script_dir(follow_symlinks=True):
    """Get the script working directory"""
    if getattr(sys, "frozen", False):
        path = os.path.abspath(sys.executable)
    else:
        path = inspect.getabsfile(get_script_dir)
    if follow_symlinks:
        path = os.path.realpath(path)
    return os.path.dirname(path)

def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return the answer"""
    valid = {"yes": True, "y": True, "ye": True, "no": False, "n": False}
    prompt = " [y/n] " if default is None else " [Y/n] " if default == "yes" else " [y/N] "
    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == "":
            return valid[default]
        if choice in valid:
            return valid[choice]
        sys.stdout.write("Please respond with 'yes' or 'no' (or 'y' or 'n').\n")

DEFAULT_MACHINE = "versatilepb"
HOME = str(os.environ["HOME"])
WORKSPACE = os.environ.get("WORKSPACE", f"{HOME}/workspace")  # Simplified workspace path

def env_proxy_build_args(env):
    ret = []
    if env:
        prox = env.split()
        for i in range(len(prox) - 1, -1, -1):
            ret += ["--env", prox[i]]
    return ret

proxy_args = env_proxy_build_args(os.environ.get("PROXY", []))
DOCKER = os.environ.get("DOCKER", "docker")
DOCKER_IMG_NAME = os.environ.get("DOCKER_IMG_NAME", "openbmc/ubuntu-robot-qemu")
OBMC_QEMU_BUILD_DIR = os.environ.get("OBMC_QEMU_BUILD_DIR", "/tmp/openbmc/build")
UPSTREAM_WORKSPACE = os.environ.get("UPSTREAM_WORKSPACE", None)

if not UPSTREAM_WORKSPACE:
    sys.exit("env var UPSTREAM_WORKSPACE is required and not set")

MACHINE = os.environ.get("MACHINE", DEFAULT_MACHINE)
KEEP_QEMU_PERSISTENT = os.environ.get("KEEP_QEMU_PERSISTENT", False)
HOSTNETWORKING = os.environ.get("HOSTNETWORKING", False)
HOSTBINPERSIST = os.environ.get("HOSTBINPERSIST", False)
HOSTBIN = os.environ.get("HOSTBIN", False)
OBMC_QEMU_DOCKER = os.environ.get("OBMC_QEMU_DOCKER", False)

if OBMC_QEMU_DOCKER and not docker_inspect_check(OBMC_QEMU_DOCKER, exit_on_fail=False):
    OBMC_QEMU_DOCKER = None  # Failed the check, clobber invalid value

DEFAULT_IMAGE_LOC = os.environ.get("DEFAULT_IMAGE_LOC", "/tmp/deploy/images/")
INTERACT = os.environ.get("INTERACT", False)

# Determine the prefix of the Dockerfile's base image and the QEMU_ARCH variable
ARCH = os.uname().machine
if ARCH == "ppc64le":
    QEMU_ARCH = "ppc64le-linux"
elif ARCH == "x86_64":
    QEMU_ARCH = "x86_64-linux"
elif ARCH == "aarch64":
    QEMU_ARCH = "arm64-linux"
else:
    sys.exit(f"Unsupported system architecture({ARCH}) found for docker image")

QEMU_BIN = os.environ.get("QEMU_BIN", f"./tmp/sysroots/{QEMU_ARCH}/usr/bin/qemu-system-arm")
SSH_PORT = os.environ.get("SSH_PORT", "22")
HTTPS_PORT = os.environ.get("HTTPS_PORT", "443")
DIR = get_script_dir()

if MACHINE == DEFAULT_MACHINE:
    MACHINE_QEMU = ""
else:
    MACHINE_QEMU = MACHINE

def docker_build_image():
    """Build the Docker image"""
    try:
        subprocess.run(
            [DIR + "/scripts/build-qemu-robot-docker.sh", DOCKER_IMG_NAME], check=True
        )
    except subprocess.CalledProcessError as e:
        sys.exit(f"Failed to create docker: {e}")

def docker_build_pull_image(image):
    """Build or pull the Docker image"""
    args = str.split(image)
    if len(args) > 1 and args[0] == "pull":
        try:
            subprocess.run([DOCKER, "pull", args[1]], check=True)
            return args[1]
        except subprocess.CalledProcessError as e:
            sys.exit(f"Failed to pull docker: {e}")
    else:
        docker_build_image()
        return image

def pexpect_child_interact(child, msg):
    """docker attach ARGS for an interactive session"""
    ret = subprocess.run([DOCKER, "attach", "--detach-keys=ctrl-p,ctrl-p", OBMC_QEMU_DOCKER], check=False)
    if ret.returncode not in [0, 1]:
        sys.exit(f"docker-attach: failed {msg}")

def docker_kill(container):
    """docker kill ARGS for cleanup"""
    try:
        subprocess.run([DOCKER, "stop", container], check=True)
        subprocess.run([DOCKER, "rm", container], check=True)
    except subprocess.CalledProcessError as e:
        print(f"docker_kill: {e}")

def docker_run(args, msg):
    """docker run"""
    try:
        ret = subprocess.run([DOCKER, "run"] + args, capture_output=True, check=True)
        return ret.stdout.decode("utf-8").rstrip()
    except subprocess.CalledProcessError as e:
        sys.exit(f"docker-run failed {msg}: {e}")

def main():
    """Main method"""
    global OBMC_QEMU_DOCKER
    global DOCKER_IMG_NAME
    global HOSTNETWORKING

    DOCKER_IMG_NAME = docker_build_pull_image(DOCKER_IMG_NAME)
    rm_arg = [] if KEEP_QEMU_PERSISTENT else ["--rm"]
    pod_args = ["--pod", "new:robot"] if DOCKER == "podman" and not HOSTBIN else []

    sh.cp(f"{DIR}/scripts/boot-qemu-test.py", UPSTREAM_WORKSPACE)
    sh.mkdir("-p", WORKSPACE)
    sh.cp(f"{DIR}/scripts/run-robot.sh", WORKSPACE)

    if HOSTBIN:
        HOSTNETWORKING = True
        if not HOSTBINPERSIST:
            child, file = qemu_child_from_hostbin()
            pexpect_child_send_expect(child)
    else:
        if OBMC_QEMU_DOCKER:
            child, file = qemu_child_persist_interact(OBMC_QEMU_DOCKER)
        else:
            child, file, qemuargs, OBMC_QEMU_DOCKER = qemu_child_new_container(
                host_networking_arg(HOSTNETWORKING) + rm_arg
            )

        if INTERACT:
            pexpect_child_interact_manually(child, "pass-through")
        else:
            if not pexpect_child_send_expect(child):
                pexpect_child_interact_manually(child, "manual fallback")

        ip_address = qemu_child_get_ip(OBMC_QEMU_DOCKER)
        child = None

    os.system(
        f"sshpass -p 0penBmc ssh root@{ip_address} -p 2222 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null systemctl is-system-running && sleep 10"
    )

    now = datetime.now()
    print("Robot Test started, " + now.strftime("%Y-%m-%d %H:%M:%S"))

    args = (
        rm_arg
        + pod_args
        + proxy_args
        + host_networking_arg(HOSTNETWORKING)
        + [
            "--env", f"HOME={HOME}",
            "--env", f"IP_ADDR={ip_address}",
            "--env", f"SSH_PORT={SSH_PORT}",
            "--env", f"HTTPS_PORT={HTTPS_PORT}",
            "--env", f"MACHINE={MACHINE_QEMU}",
            "--workdir", HOME,
            "--volume", f"{WORKSPACE}:{HOME}",
            "--tty", "--interactive",
            DOCKER_IMG_NAME, f"{HOME}/run-robot.sh",
        ]
    )

    OBMC_ROBOT_DOCKER = docker_run(args, "obmc_robot_docker")
    if not (KEEP_QEMU_PERSISTENT or HOSTBINPERSIST):
        docker_stop(OBMC_QEMU_DOCKER, "persistent QEMU container")

    if file:
        sh.rm(file)

if __name__ == "__main__":
    main()