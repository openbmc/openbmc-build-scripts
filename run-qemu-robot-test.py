#!/bin/bash -xe
###############################################################################
#
# This script is for starting QEMU against the input build and running the
# robot CI test suite against it.(ROBOT CI TEST CURRENTLY WIP)
#
###############################################################################
#
# Parameters used by the script:
#  UPSTREAM_WORKSPACE = The directory from which the QEMU components are being
#                       imported from. Generally, this is the build directory
#                       that is generated by the OpenBMC build-setup.sh script
#                       when run with "target=qemuarm".
#                       Example: /home/builder/workspace/openbmc-build/build.
#
# Optional Variables:
#
#  WORKSPACE          = Path of the workspace directory where some intermediate
#                       files will be saved to.
#  QEMU_RUN_TIMER     = Defaults to 300, a timer for the QEMU container.
#  QEMU_LOGIN_TIMER   = Defaults to 180, a timer for the QEMU container to reach
#                       login.
#  DOCKER_IMG_NAME    = Defaults to openbmc/ubuntu-robot-qemu, the name the
#                       Docker image will be tagged with when built.
#  OBMC_QEMU_BUILD_DIR     = Defaults to /tmp/openbmc/build, the path to the
#                       directory where the UPSTREAM_WORKSPACE build files will
#                       be mounted to. Since the build containers have been
#                       changed to use /tmp as the parent directory for their
#                       builds, move the mounting location to be the same to
#                       resolve issues with file links or referrals to exact
#                       paths in the original build directory. If the build
#                       directory was changed in the build-setup.sh run, this
#                       variable should also be changed. Otherwise, the default
#                       should be used.
#  LAUNCH             = Used to determine how to launch the qemu robot test
#                       containers. The options are "local", and "k8s". It will
#                       default to local which will launch a single container
#                       to do the runs. If specified k8s will launch a group of
#                       containers into a kubernetes cluster using the helper
#                       script.
#  QEMU_BIN           = Location of qemu-system-arm binary to use when starting
#                       QEMU relative to upstream workspace.  Default is
#                       ./tmp/sysroots/${QEMU_ARCH}/usr/bin/qemu-system-arm
#                       which is the default location when doing a bitbake
#                       of obmc-phosphor-image. If you don't find the sysroots
#                       folder, run `bitbake build-sysroots`.
#
#  MACHINE            = Machine to run test against. The options are "witherspoon",
#                       "palmetto", "romulus", or undefined (default).  Default
#                       will use the versatilepb model.
#
#  DEFAULT_IMAGE_LOC  = The image location of the target MACHINE. Default to
#                       "./tmp/deploy/images/"
#
###############################################################################

import argparse
import glob
import inspect
import os
import signal
import sh
import subprocess
import sys
from datetime import datetime
from pathlib import Path

HOME=str(os.environ['HOME'])

# Keep shell variables as strings
try:
    QEMU_RUN_TIMER=str(os.environ['QEMU_RUN_TIMER'])
except Exception as e:
    QEMU_RUN_TIMER=str(300)

try:
    QEMU_LOGIN_TIMER=os.environ['QEMU_LOGIN_TIMER']
except Exception as e:
    QEMU_LOGIN_TIMER=180

try:
    WORKSPACE=os.environ['WORKSPACE']
except:
    WORKSPACE=HOME +"/${RANDOM}${RANDOM}}"

#os.environ['']
try:
    DOCKER_IMG_NAME=os.environ['DOCKER_IMG_NAME']
except:
    DOCKER_IMG_NAME="openbmc/ubuntu-robot-qemu"

try:
    OBMC_QEMU_BUILD_DIR=os.environ['OBMC_QEMU_BUILD_DIR']
except:
    OBMC_QEMU_BUILD_DIR="/tmp/openbmc/build"

# Set UPSTREAM_WORKSPACE to argument 1 if present
#
#parser = argparse.ArgumentParser()
#parser.add_argument("one", action=)
#parser_args = parser.parse_args()
#one = Path(parser_args.one)

try:
    UPSTREAM_WORKSPACE=os.environ['UPSTREAM_WORKSPACE']
except:
#    UPSTREAM_WORKSPACE=${UPSTREAM_WORKSPACE:-${1}}
#    UPSTREAM_WORKSPACE=one
    print("UPSTREAM_WORKSPACE not set")
    UPSTREAM_WORKSPACE=""

try:
    LAUNCH=os.environ['LAUNCH']
except:
    LAUNCH="local"

DEFAULT_MACHINE="versatilepb"

try:
    MACHINE=os.environ['MACHINE']
except:
    MACHINE=DEFAULT_MACHINE

try:
    DEFAULT_IMAGE_LOC=os.environ['DEFAULT_IMAGE_LOC']
except:
    DEFAULT_IMAGE_LOC="/tmp/deploy/images/"

try:
    if (int(os.environ['INTERACT']) != "0"):
        interact=True
    else:
        interact=False
except Exception as e:
    interact=False

# hard exit on failure
def docker_inspect_check(m):
    # Sanity check:
    ret = subprocess.run(["docker", "inspect", obmc_qemu_docker], capture_output=True)
    if ret.returncode != 0:
        sys.exit("docker-inspect: failed " + m)
    else:
        print("docker-inspect: succeeded " + m)

    return ret

def docker_attach_interactive(m):
    ret = subprocess.run(["docker", "attach", obmc_qemu_docker])
    if ret.returncode != 0:
        if ret.returncode != 1:
            print(ret)
            sys.exit("docker-attach: failed " + m)

    print("docker-attach: succeeded " + m)

try:
    global obmc_qemu_docker
    obmc_qemu_docker=os.environ['obmc_qemu_docker']
    # Example:
    #203b45297effa49d4e4049afb491fc7152f5414dc08f08613e01871e8a36664b
    # Sanity check:
    if len(obmc_qemu_docker) == 64: # full length of the docker container
        print("docker container variable found, obmc_qemu_docker=" + obmc_qemu_docker.rstrip())

        # Sanity check: test docker_inspect and exit on failure
        docker_inspect_check("env variable")

        persist=True
    else:
        print("docker container variable incorrect length, len(obmc_qemu_docker)=", len(obmc_qemu_docker))
        persist=False
except Exception as e:
    print("Docker instance not found")
    persist=False
finally:
    pass

#sys.exit("Test")

# The automated test suite needs a real machine type so
# if we're using versatilepb for our qemu start parameter
# then we need to just let our run-robot use the default
if MACHINE == DEFAULT_MACHINE:
    MACHINE_QEMU=""
else:
    MACHINE_QEMU=MACHINE

# Determine the architecture
ARCH=sh.uname(["-m"]).rstrip()
print(ARCH)

# Determine the prefix of the Dockerfile's base image and the QEMU_ARCH variable
match ARCH:
    case "ppc64le":
        QEMU_ARCH="ppc64le-linux"
    case "x86_64":
        QEMU_ARCH="x86_64-linux"
    case "aarch64":
        QEMU_ARCH="arm64-linux"
    case _:
        sys.exit(f"Unsupported system architecture({ARCH}) found for docker image")

# Set the location of the qemu binary relative to UPSTREAM_WORKSPACE
try:
    QEMU_BIN=os.environ['QEMU_BIN']
except:
    QEMU_BIN=f"./tmp/sysroots/{QEMU_ARCH}/usr/bin/qemu-system-arm"

def signal_handler(sig, frame):
    print("signal hander")
    print(sig)
    print(frame)

def docker_kill(A):
    try:
        subprocess.run(["/usr/bin/docker", "stop", A])
        subprocess.run(["/usr/bin/docker", "rm", A])
    except subprocess.CalledProcessError as e:
        print(e)

def clean_up():
    print("Ctrl + C interrupt, cleaning up now")

    docker_kill(obmc_qemu_docker)
    subprocess.run(["/usr/bin/docker", "ps", "-a"])
#
def docker_post_run():
    pass


# Receipt from https://code.activestate.com/recipes/577058/
#
def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
            It must be "yes" (the default), "no" or None (meaning
            an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True, "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == "":
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' " "(or 'y' or 'n').\n")

# get script working directory
def get_script_dir(follow_symlinks=True):
    if getattr(sys, 'frozen', False): # py2exe, PyInstaller, cx_Freeze
        path = os.path.abspath(sys.executable)
    else:
        path = inspect.getabsfile(get_script_dir)
    if follow_symlinks:
        path = os.path.realpath(path)
    return os.path.dirname(path)

# Local overrides
#MACHINE="fby35"
MACHINE="yosemite4"
QEMU_BIN="/home/bhuey/local/builds/qemu/build/qemu-system-arm"
DEFAULT_IMAGE_LOC="/home/bhuey/local/builds/build-fby35/tmp/deploy/images/fby35"
HOME="/home/bhuey"
QEMU_RUN_TIMER=str(800)

interact=True

signal.signal(signal.SIGINT, signal_handler)

# Get the base directory of the openbmc-build-scripts repo so we can return
DIR=get_script_dir()

# Create the base Docker image for QEMU and Robot
# shellcheck source=scripts/build-qemu-robot-docker.sh
try:
    ret = subprocess.run([DIR + "/scripts/build-qemu-robot-docker.sh", DOCKER_IMG_NAME])
except subprocess.CalledProcessError as e:
    print(e)

# Copy the scripts to qemu build dir for the container
sh.cp(glob.glob(DIR + "/scripts/boot-qemu*"), UPSTREAM_WORKSPACE)
sh.ls("-al", glob.glob(UPSTREAM_WORKSPACE + "/boot-qemu*"))

# send/expect bits
timeoutlist=["Login timed out after 60 seconds."]# + [pexpect.TIMEOUT]
def match_it(match, mesg):
    ret=0
    if (match == 0):
        print(mesg)
        date()
        return 0
    elif (match == 1):
        print("timeout")
        return 1
    else:
        print("unexpected index")
        return 2

def docker_send_expect():
    try:
        print("try\n\n")
        date()
        child = pexpect.spawn(QEMU_BIN, args, timeout=None, encoding='utf-8')
        child.delaybeforesend = 0.5

        if interact == False:
            child.logfile = sys.stdout
#           child.logfile_send = sys.stdout
            print("non interactive")
            while True:
                match = child.expect(['.* login: '] + timeoutlist)
                if match_it(match, "got login"):
                    continue

                child.sendline('root')

                match = child.expect(['Password:'] + timeoutlist)
                if match_it(match, "got password"):
                    continue

                child.sendline('0penBmc')

                #root@yosemite4:~#
                match = child.expect(['.*root@.*:~#.*'] + timeoutlist)
                if match_it(match, "got prompt"):
                    continue
                else:
                    break
        else:
            print("interactive")
            #child.interact(input_filter=None, output_filter=None)
            child.interact()

        print("OPENBMC-READY\n") # signal we are ready
    except pexpect.exceptions.TIMEOUT:
        print("pexpect.exception.TIMEOUT")
    except Exception as e:
        print("pexpect: exception")
        print("Exception: {}".format(str(e)))
        print("type = {}".format(type(e)))
        print(str(e))
        print("pexpect: exception end")
    finally:
        # sleep and hold this container until we are done with testing
        # we can improve on this.
        #time.sleep(int(QEMU_RUN_TIMER))

        child.close()
        print("child.exitstatus =\t{}".format(child.exitstatus))
        print("child.signalstatus =\t{}".format(child.signalstatus))
        print("try-end\n\n")

    #child.expect(pexpect.EOF)
    #child.wait()
    rm(IMGFILE, IMGFILE_EMMC)

    print("OPENBMC-EXITING\n")

#### main ####
if LAUNCH == "local":
    # Start QEMU docker instance
    # root in docker required to open up the https/ssh ports

    if persist == False:
        # Command must be a string and not separated by a list delimiter
        # Example:
        # "/usr/bin/tail -f /var/log/bootstrap.log"]
        # "/usr/bin/tail", "-n5", "/var/log/bootstrap.log"]
        # "/usr/bin/top", "-b"]
        # "/usr/bin/top"]
        try:
            #    "--rm", # remove for logging
            print("QEMU_BIN=" + QEMU_BIN + ", MACHINE=" + MACHINE)
            args=["/usr/bin/docker", "run",
                "--interactive",
                "--detach",
                "--user",   "root",
                "--env",    f"HOME={OBMC_QEMU_BUILD_DIR}",
                "--env",    f"OBMC_QEMU_BUILD_DIR={OBMC_QEMU_BUILD_DIR}",
                "--env",    f"QEMU_RUN_TIMER={QEMU_RUN_TIMER}",
                "--env",    f"QEMU_ARCH={QEMU_ARCH}",
                "--env",    f"QEMU_BIN={QEMU_BIN}",
                "--env",    f"MACHINE={MACHINE}",
                "--env",    f"DEFAULT_IMAGE_LOC={DEFAULT_IMAGE_LOC}",
                "--workdir", f"{OBMC_QEMU_BUILD_DIR}",
                "--volume", f"{UPSTREAM_WORKSPACE}:{OBMC_QEMU_BUILD_DIR}:ro",
                "--tty",
                DOCKER_IMG_NAME,
                f"{OBMC_QEMU_BUILD_DIR}/boot-qemu-test.py"]

            print(args)
            ret = subprocess.run(
                args,
                capture_output=True)

            obmc_qemu_docker = ret.stdout.decode("utf-8").rstrip()
            print("docker-run: obmc_qemu_docker=" + obmc_qemu_docker)
            print(ret.stdout)

            docker_inspect_check("in main")
        except subprocess.CalledProcessError as e:
            print(e)
            sys.exit("docker-run failed")
    else:
        # docker container is persistent, attach to an existing container and
	# interactive exit the shell to a login prompt point
        while True:
            docker_attach_interactive("logout")
            if query_yes_no("Logged out ?"):
                break

    print("main: obmc_qemu_docker=" + obmc_qemu_docker)

    # We can use default ports because we're going to have the 2
    # docker instances talk over their private network
    DOCKER_SSH_PORT=22
    DOCKER_HTTPS_PORT=443

    # This docker command intermittently asserts a SIGPIPE which
    # causes the whole script to fail. The IP address comes through
    # fine on these errors so just ignore the SIGPIPE
#    trap '' PIPE

    ret = docker_inspect_check("after run")
#    grep "IPAddress\":" | tail -n1 | cut -d '"' -f 4)"
    DOCKER_QEMU_IP_ADDR=ret.stdout.decode("utf-8").rstrip()

    if interact == False:
        print("non-interactive")

        #Now wait for the OpenBMC QEMU Docker instance to get to standby
        delay=5
        attempt=QEMU_LOGIN_TIMER/delay
        while attempt > 0:
            attempt=attempt - 1
            print("Waiting for qemu to get to standby (attempt: " + attempt + ")...")
            #result=$(docker logs "$obmc_qemu_docker")
            result=docker_read_log()
###
#            if grep -q 'OPENBMC-READY' <<< "$result":
#                print("QEMU is ready!")
#                # Give QEMU a few secs to stabilize
#                time.sleep(delay)
#                break
            time.sleep(delay)

        if attempt == 0:
            sys.exit("Timed out waiting for QEMU, exiting")
    else:
        # Interactive pass-through via manual login
        while True:
            print("Interactive login pass-through")
            docker_attach_interactive("login pass-through")
            if query_yes_no("pass-through complete ?"):
                break

        print("interactive passthrough")

    if DOCKER_QEMU_IP_ADDR=="":
        print("unset DOCKER_QEMU_IP_ADDR=" + DOCKER_QEMU_IP_ADDR)
        sys.exit("exit end")
        pass

    sys.exit("Stop here")

    # Now run the Robot test (Tests commented out until they are working again)

    now = datetime.now()
    formatted = now.strftime("%Y-%m-%d %H:%M:%S")

    # Timestamp for job
    print("Robot Test started, " + formatted)

    sh.mkdir("-p", WORKSPACE)
#    cd "${WORKSPACE}"

    # Copy in the script which will execute the Robot tests
    sh.cp(DIR + "/scripts/run-robot.sh", WORKSPACE)

    # Run the Docker container to execute the Robot test cases
    # The test results will be put in ${WORKSPACE}
    try:
        subprocess.run(["docker", "run",
            "--rm",
            "--env",     f"HOME={HOME}",
            "--env",     f"IP_ADDR={DOCKER_QEMU_IP_ADDR}",
            "--env",     f"SSH_PORT={DOCKER_SSH_PORT}",
            "--env",     f"HTTPS_PORT={DOCKER_HTTPS_PORT}",
            "--env",     f"MACHINE={MACHINE_QEMU}",
            "--workdir", HOME,
            "--volume",  f"{WORKSPACE}:{HOME}",
            "--tty",
            DOCKER_IMG_NAME, f"{HOME}/run-robot.sh"]
        )
    except subprocess.CalledProcessError as e:
        print(e)

    # Now stop the QEMU Docker image
    try:
        subprocess.run(["docker",  "stop", obmc_qemu_docker])
    except subprocess.CalledProcessError as e:
        print(e)
else:
    sys.exit("LAUNCH variable invalid, Exiting")
