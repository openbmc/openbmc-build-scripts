#!/bin/bash -xe
###############################################################################
#
# This script is for starting QEMU against the input build and running the
# robot CI test suite against it.(ROBOT CI TEST CURRENTLY WIP)
#
###############################################################################
#
# Parameters used by the script:
#  UPSTREAM_WORKSPACE = The directory from which the QEMU components are being
#                       imported from. Generally, this is the build directory
#                       that is generated by the OpenBMC build-setup.sh script
#                       when run with "target=qemuarm".
#                       Example: /home/builder/workspace/openbmc-build/build.
#
# Optional Variables:
#
#  WORKSPACE          = Path of the workspace directory where some intermediate
#                       files will be saved to.
#  QEMU_RUN_TIMER     = Defaults to 300, a timer for the QEMU container.
#  QEMU_LOGIN_TIMER   = Defaults to 180, a timer for the QEMU container to reach
#                       login.
#  DOCKER_IMG_NAME    = Defaults to openbmc/ubuntu-robot-qemu, the name the
#                       Docker image will be tagged with when built.
#  OBMC_QEMU_BUILD_DIR     = Defaults to /tmp/openbmc/build, the path to the
#                       directory where the UPSTREAM_WORKSPACE build files will
#                       be mounted to. Since the build containers have been
#                       changed to use /tmp as the parent directory for their
#                       builds, move the mounting location to be the same to
#                       resolve issues with file links or referrals to exact
#                       paths in the original build directory. If the build
#                       directory was changed in the build-setup.sh run, this
#                       variable should also be changed. Otherwise, the default
#                       should be used.
#  LAUNCH             = Used to determine how to launch the qemu robot test
#                       containers. The options are "local", and "k8s". It will
#                       default to local which will launch a single container
#                       to do the runs. If specified k8s will launch a group of
#                       containers into a kubernetes cluster using the helper
#                       script.
#  QEMU_BIN           = Location of qemu-system-arm binary to use when starting
#                       QEMU relative to upstream workspace.  Default is
#                       ./tmp/sysroots/${QEMU_ARCH}/usr/bin/qemu-system-arm
#                       which is the default location when doing a bitbake
#                       of obmc-phosphor-image. If you don't find the sysroots
#                       folder, run `bitbake build-sysroots`.
#
#  MACHINE            = Machine to run test against. The options are "witherspoon",
#                       "palmetto", "romulus", or undefined (default).  Default
#                       will use the versatilepb model.
#
#  DEFAULT_IMAGE_LOC  = The image location of the target MACHINE. Default to
#                       "./tmp/deploy/images/"
#
###############################################################################

import argparse
import glob
import inspect
import os
import signal
import sh
import subprocess
import sys
from datetime import datetime
from pathlib import Path

HOME=str(os.environ['HOME'])

try:
    QEMU_RUN_TIMER=os.environ['QEMU_RUN_TIMER']
except Exception as e:
    QEMU_RUN_TIMER=300

try:
    QEMU_LOGIN_TIMER=os.environ['QEMU_LOGIN_TIMER']
except Exception as e:
    QEMU_LOGIN_TIMER=180

try:
    WORKSPACE=os.environ['WORKSPACE']
except:
    WORKSPACE=HOME +"/${RANDOM}${RANDOM}}"

#os.environ['']
try:
    DOCKER_IMG_NAME=os.environ['DOCKER_IMG_NAME']
except:
    DOCKER_IMG_NAME="openbmc/ubuntu-robot-qemu"

try:
    OBMC_QEMU_BUILD_DIR=os.environ['OBMC_QEMU_BUILD_DIR']
except:
    OBMC_QEMU_BUILD_DIR="/tmp/openbmc/build"

# Set UPSTREAM_WORKSPACE to argument 1 if present
#
#parser = argparse.ArgumentParser()
#parser.add_argument("one", action=)
#parser_args = parser.parse_args()
#one = Path(parser_args.one)

try:
    UPSTREAM_WORKSPACE=os.environ['UPSTREAM_WORKSPACE']
except:
#    UPSTREAM_WORKSPACE=${UPSTREAM_WORKSPACE:-${1}}
#    UPSTREAM_WORKSPACE=one
    print("UPSTREAM_WORKSPACE not set")
    UPSTREAM_WORKSPACE=""

try:
    LAUNCH=os.environ['LAUNCH']
except:
    LAUNCH="local"

DEFAULT_MACHINE="versatilepb"

try:
    MACHINE=os.environ['MACHINE']
except:
    MACHINE=DEFAULT_MACHINE

try:
    DEFAULT_IMAGE_LOC=os.environ['DEFAULT_IMAGE_LOC']
except:
    DEFAULT_IMAGE_LOC="/tmp/deploy/images/"

try:
    if (int(os.environ['INTERACT']) != "0"):
        interact=True
    else:
        interact=False
except Exception as e:
    interact=False

# hard exit on failure
def docker_inspect_check(m):
    # Sanity check
    ret = subprocess.run(["docker", "inspect", obmc_qemu_docker], capture_output=True)
    if ret.returncode != 0:
        sys.exit("docker-inspect: failed " + m)
    else:
        print("docker-inspect: succeeded " + m)

try:
    global obmc_qemu_docker
    obmc_qemu_docker=os.environ['obmc_qemu_docker']
    # Example:
    #99d7c3fd875758880c7a0770f9910c83c696a1ed425c0d0d2e1a2d6256333d04200
    # Sanity
    if len(obmc_qemu_docker) == 67: # full length of the docker container
        print("docker container variable found, obmc_qemu_docker=" + obmc_qemu_docker.rstrip())

        # Sanity check: test docker_inspect and exit on failure
        docker_inspect_check("env variable")

        persist=True
    else:
        print("docker container variable incorrect length, len(obmc_qemu_docker)=", len(obmc_qemu_docker))
        persist=False
except Exception as e:
    print("Docker instance not found")
    persist=False
finally:
    pass

# The automated test suite needs a real machine type so
# if we're using versatilepb for our qemu start parameter
# then we need to just let our run-robot use the default
if MACHINE == DEFAULT_MACHINE:
    MACHINE_QEMU=""
else:
    MACHINE_QEMU=MACHINE

# Determine the architecture
ARCH=sh.uname(["-m"]).rstrip()
print(ARCH)

# Determine the prefix of the Dockerfile's base image and the QEMU_ARCH variable
match ARCH:
    case "ppc64le":
        QEMU_ARCH="ppc64le-linux"
    case "x86_64":
        QEMU_ARCH="x86_64-linux"
    case "aarch64":
        QEMU_ARCH="arm64-linux"
    case _:
        sys.exit("Unsupported system architecture(" + ARCH + ") found for docker image")

# Set the location of the qemu binary relative to UPSTREAM_WORKSPACE
try:
    QEMU_BIN=os.environ['QEMU_BIN']
except:
    QEMU_BIN="./tmp/sysroots/" + QEMU_ARCH + "/usr/bin/qemu-system-arm"

def signal_handler(sig, frame):
    print("signal hander")
    print(sig)
    print(frame)

def docker_kill(A):
    try:
        subprocess.run(["/usr/bin/docker", "stop", A])
        subprocess.run(["/usr/bin/docker", "rm", A])
    except subprocess.CalledProcessError as e:
        print(e)

def clean_up():
    print("Ctrl + C interrupt, cleaning up now")

    docker_kill(obmc_qemu_docker)
    subprocess.run(["/usr/bin/docker", "ps", "-a"])
#
def docker_post_run():
    pass


# get script working directory
def get_script_dir(follow_symlinks=True):
    if getattr(sys, 'frozen', False): # py2exe, PyInstaller, cx_Freeze
        path = os.path.abspath(sys.executable)
    else:
        path = inspect.getabsfile(get_script_dir)
    if follow_symlinks:
        path = os.path.realpath(path)
    return os.path.dirname(path)

# local overrides
#MACHINE="fby35"

MACHINE="yosemite4"
QEMU_BIN="/home/bhuey/local/builds/qemu/build/qemu-system-arm"
DEFAULT_IMAGE_LOC="/home/bhuey/local/builds/build-fby35/tmp/deploy/images/fby35"
HOME="/home/bhuey"
QEMU_RUN_TIMER=800

interact=True

signal.signal(signal.SIGINT, signal_handler)

# Get the base directory of the openbmc-build-scripts repo so we can return
DIR=get_script_dir()

# Create the base Docker image for QEMU and Robot
# shellcheck source=scripts/build-qemu-robot-docker.sh
try:
    ret = subprocess.run([DIR + "/scripts/build-qemu-robot-docker.sh", DOCKER_IMG_NAME])
except subprocess.CalledProcessError as e:
    print(e)

# Copy the scripts to qemu build dir for the container
sh.cp(glob.glob(DIR + "/scripts/boot-qemu*"), UPSTREAM_WORKSPACE)
sh.ls("-al", glob.glob(UPSTREAM_WORKSPACE + "/boot-qemu*"))

# send/expect bits
timeoutlist=["Login timed out after 60 seconds."]# + [pexpect.TIMEOUT]
def match_it(match, mesg):
    ret=0
    if (match == 0):
        print(mesg)
        date()
        return 0
    elif (match == 1):
        print("timeout")
        return 1
    else:
        print("unexpected index")
        return 2

def docker_send_expect():
    try:
        print("try\n\n")
        date()
        child = pexpect.spawn(QEMU_BIN, args, timeout=None, encoding='utf-8')
        child.delaybeforesend = 0.5

        if interact == False:
            child.logfile = sys.stdout
#           child.logfile_send = sys.stdout
            print("non interactive")
            while True:
                match = child.expect(['.* login: '] + timeoutlist)
                if match_it(match, "got login"):
                    continue

                child.sendline('root')

                match = child.expect(['Password:'] + timeoutlist)
                if match_it(match, "got password"):
                    continue

                child.sendline('0penBmc')

                #root@yosemite4:~#
                match = child.expect(['.*root@.*:~#.*'] + timeoutlist)
                if match_it(match, "got prompt"):
                    continue
                else:
                    break
        else:
            print("interactive")
            #child.interact(input_filter=None, output_filter=None)
            child.interact()

        print("OPENBMC-READY\n") # signal we are ready
    except pexpect.exceptions.TIMEOUT:
        print("pexpect.exception.TIMEOUT")
    except Exception as e:
        print("pexpect: exception")
        print("Exception: {}".format(str(e)))
        print("type = {}".format(type(e)))
        print(str(e))
        print("pexpect: exception end")
    finally:
        # sleep and hold this container until we are done with testing
        # we can improve on this.
        #time.sleep(QEMU_RUN_TIMER)

        child.close()
        print("child.exitstatus =\t{}".format(child.exitstatus))
        print("child.signalstatus =\t{}".format(child.signalstatus))
        print("try-end\n\n")

    #child.expect(pexpect.EOF)
    #child.wait()
    rm(IMGFILE, IMGFILE_EMMC)

    print("OPENBMC-EXITING\n")

#### main ####
if LAUNCH == "local":
    # Start QEMU docker instance
    # root in docker required to open up the https/ssh ports

    if persist == False:
        try:
            args=["/usr/bin/docker", "run",
                "--detach",
                "--user", "root",
                "--env", "HOME=" +              OBMC_QEMU_BUILD_DIR,
                "--env", "OBMC_QEMU_BUILD_DIR="+ OBMC_QEMU_BUILD_DIR,
                "--env", "QEMU_RUN_TIMER=" +    str(QEMU_RUN_TIMER),
                "--env", "QEMU_ARCH=" +         QEMU_ARCH,
                "--env", "QEMU_BIN=" +          QEMU_BIN,
                "--env", "MACHINE=" +           MACHINE,
                "--env", "DEFAULT_IMAGE_LOC=" + DEFAULT_IMAGE_LOC,
                "--workdir",                    OBMC_QEMU_BUILD_DIR,
                "--volume",			UPSTREAM_WORKSPACE + ":" + OBMC_QEMU_BUILD_DIR + ":ro",
                "--tty",
                DOCKER_IMG_NAME,
                "/usr/bin/tail", "-f", "/var/log/syslog"]
#                "/usr/bin/python3", OBMC_QEMU_BUILD_DIR + "/boot-qemu-test.py"]
            print(args)

            ret = subprocess.run(
                args,
                capture_output=True)

            obmc_qemu_docker = ret.stdout.decode("utf-8").rstrip()
            print("docker_run: obmc_qemu_docker=" + obmc_qemu_docker)
            print(ret.stdout)

            docker_inspect_check("in main")

        except subprocess.CalledProcessError as e:
            print(e)
    else:
        # persistent therefore attach to an existing container and exit the
        # shell so that interactive code can be tested
        pass

    print("main: obmc_qemu_docker=" + obmc_qemu_docker)

    # We can use default ports because we're going to have the 2
    # docker instances talk over their private network
    DOCKER_SSH_PORT=22
    DOCKER_HTTPS_PORT=443

    # This docker command intermittently asserts a SIGPIPE which
    # causes the whole script to fail. The IP address comes through
    # fine on these errors so just ignore the SIGPIPE
#    trap '' PIPE

    try:
        ret = subprocess.run(["docker", "inspect", obmc_qemu_docker], capture_output=True)
#    grep "IPAddress\":" | tail -n1 | cut -d '"' -f 4)"
        DOCKER_QEMU_IP_ADDR=ret.stdout
        print(str(ret))
    except subprocess.CalledProcessError as e:
        print(e)

    sys.exit(1)

    if interact == False:
        print("non-interactive")

        #Now wait for the OpenBMC QEMU Docker instance to get to standby
        delay=5
        attempt=QEMU_LOGIN_TIMER/delay
        while attempt > 0:
            attempt=attempt - 1
            print("Waiting for qemu to get to standby (attempt: " + attempt + ")...")
            #result=$(docker logs "$obmc_qemu_docker")
            result=docker_read_log()
###
#            if grep -q 'OPENBMC-READY' <<< "$result":
#                print("QEMU is ready!")
#                # Give QEMU a few secs to stabilize
#                time.sleep(delay)
#                break
            time.sleep(delay)

        if attempt == 0:
            sys.exit("Timed out waiting for QEMU, exiting")
    else:
	    # pass-through via interactive keyboard command
        # subprocess.run(["docker", "attach, obmc_qemu_docker]
    	print("interactive passthrough")

    # Now run the Robot test (Tests commented out until they are working again)

    now = datetime.now()
    formatted = now.strftime("%Y-%m-%d %H:%M:%S")

    # Timestamp for job
    print("Robot Test started, " + formatted)

    sh.mkdir("-p", WORKSPACE)
#    cd "${WORKSPACE}"

    # Copy in the script which will execute the Robot tests
#    cp "$DIR"/scripts/run-robot.sh "${WORKSPACE}"
    sh.cp(DIR + "/scripts/run-robot.sh ", WORKSPACE)

    # Run the Docker container to execute the Robot test cases
    # The test results will be put in ${WORKSPACE}
    try:
        subprocess.run(["docker", "run",
            "--rm",
            "--env", "HOME=" +      HOME,
            "--env", "IP_ADDR=" +   DOCKER_QEMU_IP_ADDR,
            "--env", "SSH_PORT=" +  DOCKER_SSH_PORT,
            "--env", "HTTPS_PORT=" + DOCKER_HTTPS_PORT,
            "--env", "MACHINE=" +   MACHINE_QEMU,
            "--workdir",            HOME,
            "--volume",             WORKSPACE + ":" +HOME,
            "--tty",
            DOCKER_IMG_NAME, HOME + "/run-robot.sh"]
        )
    except subprocess.CalledProcessError as e:
        print(e)

    # Now stop the QEMU Docker image
    try:
        subprocess.run(["docker",  "stop", obmc_qemu_docker])
    except subprocess.CalledProcessError as e:
        print(e)
else:
    sys.exit("LAUNCH variable invalid, Exiting")
