#!/bin/bash -xe
###############################################################################
#
# This script is for starting QEMU against the input build and running the
# robot CI test suite against it.(ROBOT CI TEST CURRENTLY WIP)
#
###############################################################################
#
# Parameters used by the script:
#  UPSTREAM_WORKSPACE = The directory from which the QEMU components are being
#                       imported from. Generally, this is the build directory
#                       that is generated by the OpenBMC build-setup.sh script
#                       when run with "target=qemuarm".
#                       Example: /home/builder/workspace/openbmc-build/build.
#
# Optional Variables:
#
#  WORKSPACE          = Path of the workspace directory where some intermediate
#                       files will be saved to.
#  QEMU_LOGIN_TIMER   = Defaults to 180, a timer for the QEMU container to reach
#                       login.
#  DOCKER_IMG_NAME    = Defaults to openbmc/ubuntu-robot-qemu, the name the
#                       Docker image will be tagged with when built.
#  OBMC_QEMU_BUILD_DIR     = Defaults to /tmp/openbmc/build, the path to the
#                       directory where the UPSTREAM_WORKSPACE build files will
#                       be mounted to. Since the build containers have been
#                       changed to use /tmp as the parent directory for their
#                       builds, move the mounting location to be the same to
#                       resolve issues with file links or referrals to exact
#                       paths in the original build directory. If the build
#                       directory was changed in the build-setup.sh run, this
#                       variable should also be changed. Otherwise, the default
#                       should be used.
#  LAUNCH             = Used to determine how to launch the qemu robot test
#                       containers. The options are "local", and "k8s". It will
#                       default to local which will launch a single container
#                       to do the runs. If specified k8s will launch a group of
#                       containers into a kubernetes cluster using the helper
#                       script.
#  QEMU_BIN           = Location of qemu-system-arm binary to use when starting
#                       QEMU relative to upstream workspace.  Default is
#                       ./tmp/sysroots/${QEMU_ARCH}/usr/bin/qemu-system-arm
#                       which is the default location when doing a bitbake
#                       of obmc-phosphor-image. If you don't find the sysroots
#                       folder, run `bitbake build-sysroots`.
#
#  MACHINE            = Machine to run test against. The options are "witherspoon",
#                       "palmetto", "romulus", or undefined (default).  Default
#                       will use the versatilepb model.
#
#  DEFAULT_IMAGE_LOC  = The image location of the target MACHINE. Default to
#                       "./tmp/deploy/images/"
#
#  obmc_qemu_docker   = Use a persistent Docker container if set and valid
#
###############################################################################

import argparse
import glob
import inspect
import json
import os
import pexpect
import pprint
import signal
import sh
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path

HOME=str(os.environ['HOME'])

# This variable might no longer be needed
try:
    QEMU_LOGIN_TIMER=os.environ['QEMU_LOGIN_TIMER']
except Exception as e:
    QEMU_LOGIN_TIMER=800

try:
    WORKSPACE=os.environ['WORKSPACE']
except:
    WORKSPACE=HOME +"/${RANDOM}${RANDOM}}" # todo

#os.environ['']
try:
    DOCKER_IMG_NAME=os.environ['DOCKER_IMG_NAME']
except:
    DOCKER_IMG_NAME="openbmc/ubuntu-robot-qemu"

try:
    OBMC_QEMU_BUILD_DIR=os.environ['OBMC_QEMU_BUILD_DIR']
except:
    OBMC_QEMU_BUILD_DIR="/tmp/openbmc/build"

try:
    UPSTREAM_WORKSPACE=os.environ['UPSTREAM_WORKSPACE']
except:
    sys.exit("UPSTREAM_WORKSPACE is required and not set")

try:
    LAUNCH=os.environ['LAUNCH']
except:
    LAUNCH="local"

DEFAULT_MACHINE="versatilepb"

try:
    MACHINE=os.environ['MACHINE']
except:
    MACHINE=DEFAULT_MACHINE

try:
    DEFAULT_IMAGE_LOC=os.environ['keep_persistent']
    keep_persistent=True
except:
    keep_persistent=False

try:
    DEFAULT_IMAGE_LOC=os.environ['DEFAULT_IMAGE_LOC']
except:
    DEFAULT_IMAGE_LOC="/tmp/deploy/images/"

try:
    if (int(os.environ['INTERACT']) != "0"):
        interact=True
    else:
        interact=False

except Exception as e:
    interact=False

def docker_inspect_check(m, container=None, fail=True):
    # Sanity check:
    ret = subprocess.run(["docker", "inspect", container], capture_output=True)
    if ret.returncode != 0:
        if fail:
            sys.exit("docker-inspect: failed " + m)
    else:
        print("docker-inspect: succeeded " + m)

    return ret

try:
    global obmc_qemu_docker
    obmc_qemu_docker=os.environ['obmc_qemu_docker']

    ret=docker_inspect_check(f"docker-inspect: obmc_qemu_docker={obmc_qemu_docker}", container=obmc_qemu_docker, fail=False)
    if ret.returncode == 0:
        persistqemu=True
    else:
        persistqemu=False
except Exception as e:
    print(e)
    persistqemu=False
    obmc_qemu_docker=None
finally:
    print(f"obmc_qemu_docker={obmc_qemu_docker}, persistqemu={persistqemu}")
    pass

def docker_attach_run(m):
    print("docker_attach_run:")
    ret = subprocess.run(["docker", "attach", obmc_qemu_docker])
    if ret.returncode != 0:
        # returncode = 1 is ok
        if ret.returncode != 1:
            print(ret)
            sys.exit("docker-attach-run: failed {m}")

def docker_attach_interact(m):
    print("docker_attach_interact:")
    ret = subprocess.run(["docker", "attach", obmc_qemu_docker])
    if ret.returncode != 0:
        # returncode = 1 is ok
        if ret.returncode != 1:
            print(ret)
            sys.exit("docker-attach: failed {m}")

    print("docker-attach: succeeded {m}")

# The automated test suite needs a real machine type so
# if we're using versatilepb for our qemu start parameter
# then we need to just let our run-robot use the default
if MACHINE == DEFAULT_MACHINE:
    MACHINE_QEMU=""
else:
    MACHINE_QEMU=MACHINE

# Determine the architecture
ARCH=sh.uname(["-m"]).rstrip()
print(ARCH)

# Determine the prefix of the Dockerfile's base image and the QEMU_ARCH variable
match ARCH:
    case "ppc64le":
        QEMU_ARCH="ppc64le-linux"
    case "x86_64":
        QEMU_ARCH="x86_64-linux"
    case "aarch64":
        QEMU_ARCH="arm64-linux"
    case _:
        sys.exit(f"Unsupported system architecture({ARCH}) found for docker image")

# Set the location of the qemu binary relative to UPSTREAM_WORKSPACE
try:
    QEMU_BIN=os.environ['QEMU_BIN']
except:
    QEMU_BIN=f"./tmp/sysroots/{QEMU_ARCH}/usr/bin/qemu-system-arm"

def signal_handler(sig, frame):
    print("signal hander")
    print(sig)
    print(frame)

def docker_kill(A):
    try:
        subprocess.run(["/usr/bin/docker", "stop", A])
        subprocess.run(["/usr/bin/docker", "rm", A])
    except subprocess.CalledProcessError as e:
        print(e)

def clean_up():
    print("Ctrl + C interrupt, cleaning up now")

    docker_kill(obmc_qemu_docker)
    subprocess.run(["/usr/bin/docker", "ps", "-a"])
#
def docker_post_run():
    pass


# Receipt from https://code.activestate.com/recipes/577058/
#
def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
            It must be "yes" (the default), "no" or None (meaning
            an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True, "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == "":
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' " "(or 'y' or 'n').\n")

# get script working directory
def get_script_dir(follow_symlinks=True):
    if getattr(sys, 'frozen', False): # py2exe, PyInstaller, cx_Freeze
        path = os.path.abspath(sys.executable)
    else:
        path = inspect.getabsfile(get_script_dir)
    if follow_symlinks:
        path = os.path.realpath(path)
    return os.path.dirname(path)

#signal.signal(signal.SIGINT, signal_handler)

# Get the base directory of the openbmc-build-scripts repo so we can return
DIR=get_script_dir()

# Create the base Docker image for QEMU and Robot
# shellcheck source=scripts/build-qemu-robot-docker.sh
try:
    ret = subprocess.run([DIR + "/scripts/build-qemu-robot-docker.sh", DOCKER_IMG_NAME])
except subprocess.CalledProcessError as e:
    print(e)

# Copy container scripts
sh.cp(glob.glob(DIR + "/scripts/boot-qemu*"), UPSTREAM_WORKSPACE)
sh.ls("-al", glob.glob(UPSTREAM_WORKSPACE + "/boot-qemu*"))

# send/expect bits
timeoutlist=["Login timed out after 60 seconds."]# + [pexpect.TIMEOUT]
def match_it(match, mesg):
    ret=0
    if (match == 0):
        print(mesg)
        return 0
    elif (match == 1):
        print("timeout")
        return 1
    else:
        print("unexpected index")
        return 2

def docker_attach_send_expect():
    print("docker_attach_send_expect:")
    try:
        #docker-attach
        child = pexpect.spawn("docker", ["attach", obmc_qemu_docker], timeout=None, encoding='utf-8')
        child.delaybeforesend = 0.5

        child.logfile = sys.stdout
#       child.logfile_send = sys.stdout

        child.sendline('')
        while True:
            match = child.expect(['.* login: '] + timeoutlist)
            if match_it(match, "got login"):
                continue

            child.sendline('root')

            match = child.expect(['Password:'] + timeoutlist)
            if match_it(match, "got password"):
                continue

            child.sendline('0penBmc')

            #root@yosemite4:~#
            match = child.expect(['.*root@.*:~#.*'] + timeoutlist)
            if match_it(match, "got prompt"):
                continue
            else:
                break

        child.sendline('')
    except Exception as e:
        print("docker_attach_send_expect: exception")
        print(e)
        return False

    child.close() # attach close
    print("child.exitstatus =\t{}".format(child.exitstatus))
    print("child.signalstatus =\t{}".format(child.signalstatus))
    return True

def interact_attach_manually(a):
    while True:
        print(f"interact_attach_manually: {a}")
        #attach and type manually to bypass
        docker_attach_interact(a)
        if query_yes_no("{a} complete ?", default="no"):
            break

def docker_stop(container, m):
    try:
        subprocess.run(["docker",  "stop", container])
    except subprocess.CalledProcessError as e:
        print(f"docker_stop: {m}")
        print(e)

def docker_run(args, m):
    try:
        print(f"docker_run: {args}")
        ret = subprocess.run(
            args,
            capture_output=True)
        print(f"docker-run: ret={ret}")
    except subprocess.CalledProcessError as e:
        print(e)
        sys.exit(f"docker-run failed {m}")

    c = ret.stdout.decode("utf-8").rstrip()
    print(f"docker-run: {m}={c}")
    return c

if keep_persistent:
    remove=[]
else:
    remove=["--rm"]

#### main ####
if LAUNCH == "local":
    # Start QEMU docker instance
    # root in docker required to open up the https/ssh ports

    if persistqemu:
        # docker container is persistent, attach to an existing container and
	# interactive exit the shell to a login prompt point
        while True:
            print("exit to login prempt>")
            docker_attach_interact("logout")
            if query_yes_no("Logged out ?", default="no"):
                break
    else:
        args=["/usr/bin/docker", "run"] + remove + [
            "--interactive",
            "--detach",
            "--user",   "root",
            "--env",    f"HOME={OBMC_QEMU_BUILD_DIR}",
            "--env",    f"OBMC_QEMU_BUILD_DIR={OBMC_QEMU_BUILD_DIR}",
            "--env",    f"QEMU_ARCH={QEMU_ARCH}",
            "--env",    f"QEMU_BIN={QEMU_BIN}",
            "--env",    f"MACHINE={MACHINE}",
            "--env",    f"DEFAULT_IMAGE_LOC={DEFAULT_IMAGE_LOC}",
            "--workdir", f"{OBMC_QEMU_BUILD_DIR}",
            "--volume", f"{UPSTREAM_WORKSPACE}:{OBMC_QEMU_BUILD_DIR}:ro",
            "--tty",
            DOCKER_IMG_NAME,
            f"{OBMC_QEMU_BUILD_DIR}/boot-qemu-test.py"]
        obmc_qemu_docker = docker_run(args, "obmc_qemu_docker")

    print("main:")

    # We can use default ports because we're going to have the 2
    # docker instances talk over their private network
    DOCKER_SSH_PORT=22
    DOCKER_HTTPS_PORT=443

    # This docker command intermittently asserts a SIGPIPE which
    # causes the whole script to fail. The IP address comes through
    # fine on these errors so just ignore the SIGPIPE
#    trap '' PIPE

    # originally from a docker inspect
    #grep "IPAddress\":" | tail -n1 | cut -d '"' -f 4)"

    ret = docker_inspect_check("after run", obmc_qemu_docker)

    json_stream=ret.stdout.decode("utf-8").rstrip()
    json_data=json.loads(json_stream)

    IPAddress=(json_data[0]["NetworkSettings"])["IPAddress"]
    #pprint.pprint(json_data)

    if IPAddress == "":
        sys.exit(f"IPAddress={IPAddress} bogus")

    print(type(IPAddress))
    print(f"obmc_qemu_docker={obmc_qemu_docker}, IPAddress={IPAddress}")

    if interact:
        # manual login
        print("interactive passthrough")
        interact_attach_manually("interactive passthrough")
    else:
        #send-expect and then manually fallback on a timeout
        print("non-interactive")
        if not docker_attach_send_expect():
            interact_attach_manually("manual fallback")

    # Now run the Robot test (Tests commented out until they are working again)
    now = datetime.now()
    formatted = now.strftime("%Y-%m-%d %H:%M:%S")

    # Timestamp for job
    print("Robot Test started, " + formatted)

    sh.mkdir("-p", WORKSPACE)
#    cd "${WORKSPACE}"

    # Copy in the script which will execute the Robot tests
    sh.cp(DIR + "/scripts/run-robot.sh", WORKSPACE)

    args=["docker", "run",
        "--env",     f"HOME={HOME}",
        "--env",     f"IP_ADDR={IPAddress}",
        "--env",     f"SSH_PORT={DOCKER_SSH_PORT}",
        "--env",     f"HTTPS_PORT={DOCKER_HTTPS_PORT}",
        "--env",     f"MACHINE={MACHINE_QEMU}",
        "--workdir", HOME,
        "--volume",  f"{WORKSPACE}:{HOME}",
        "--tty",
        "--rm",
        DOCKER_IMG_NAME, f"{HOME}/run-robot.sh"]

    # Run the Docker container to execute the Robot test cases
    # The test results will be put in ${WORKSPACE}
    docker_run(args, "obmc_robot_docker")

    if not keep_persistent and not persistqemu:
        docker_stop(obmc_qemu_docker, "persistent QEMU container")
else:
    sys.exit("LAUNCH variable invalid, Exiting")
